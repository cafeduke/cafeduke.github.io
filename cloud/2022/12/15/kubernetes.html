<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <!-- Meta data -->
    <meta charset="utf-8">
<meta name="viewport" content="initial-scale=1, shrink-to-fit=no, width=device-width">
<meta http-equiv="x-ua-compatible" content="ie=edge">

    <!-- Window title -->
    <title>Kubernetes Essentials</title>

    <!-- CSS -->
    <!-- Material fonts from 'https://fonts.google.com' -->
<link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,500,500i,700,700i" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto+Mono:300,300i,400,400i,500,500i,700,700i" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,500,500i,700,700i" rel="stylesheet"> 
<link href="https://fonts.googleapis.com/css?family=Vollkorn:300,300i,400,400i,500,500i,700,700i" rel="stylesheet"> 

<!-- Material Icon -->
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<!-- Font Awesome Icon -->
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">

<!-- Add Material CSS. Replace Bootstrap CSS -->
<link href="/assets/daemonite-material/css/material.min.css" rel="stylesheet">

<!-- Material Color Palette - CSS Classes -->
<link href="/assets/material-design-color-palette/css/material-design-color-palette.css" rel="stylesheet">

<!-- CafeDuke CSS - Project specific Classes  -->
<link href="/assets/css/main.css" rel="stylesheet" type="text/css">

<!-- CafeDuke Syntax CSS - Code syntax highlight -->
<link href="/assets/css/duke-dark.css" rel="stylesheet" type="text/css">


<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

    <!-- Navigation bar -->
    <nav class="navbar navbar-expand-lg navbar-dark mdc-bg-purple-900">
    
    

    <!-- Collapse Icon -->
    <a id="sidebar-toggle" class="navbar-brand text-white" href="">
        <i class="material-icons md-24">menu</i>
    </a>

    <!-- NavBar Heading -->
    <a class="navbar-brand text-white" href="/">Cafe Duke Notes</a>

    <!-- Collapse button -->
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">

        <!-- Links -->
        <ul class="navbar-nav mr-auto">


        </ul>
        <!-- Links -->

        <!-- Search form
        <form class="form-inline">
            <input class="form-control mr-sm-2" type="text" placeholder="Search" aria-label="Search">
        </form>
         -->

    </div>
    <!-- Collapsible content -->

</nav>


    <!-- Row: Content -->
    <div class="container-fluid m-0 p-0 h-100">

        <div class="row h-100 no-gutters">

            <!-- Column: Sidebar -->
            <div id="sidebar">

    <ul class="nav flex-column">

        <li class="nav-item">
            <a class="nav-link d-flex align-items-center" href="/">
                <i class="fas fa-home fa-lg"></i>
                <span class="nav-link-text">Home</span>
            </a>
        </li>

        <li class="nav-item">
            <a class="nav-link d-flex align-items-center" href="/java">
                <i class="fab fa-java fa-2x"></i>
                <span class="nav-link-text">Java</span>
            </a>
        </li>

        <li class="nav-item">
            <a class="nav-link d-flex align-items-center" href="/git">
                <i class="fab fa-git fa-lg"></i>
                <span class="nav-link-text">Git</span>
            </a>
        </li>

        <li class="nav-item">
            <a class="nav-link d-flex align-items-center" href="/cloud">
                <i class="material-icons md-24">cloud</i>
                <span class="nav-link-text">Cloud</span>
            </a>
        </li>

        <li class="nav-item">
            <a class="nav-link d-flex align-items-center" data-toggle="collapse" data-target="#child-dl" href="#">
                <i class="fas fa-cogs fa-lg"></i>
                <span class="nav-link-text">Deep Learning</span>
            </a>
            <div id="child-dl" class="collapse">
                <ul class="nav flex-column">
                    <li class="nav-item">
                        <a class="nav-link d-flex align-items-center" href="/deeplearning">
                            <span class="nav-link-text">Core</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link d-flex align-items-center" href="/deeplearning/strategy">
                            <span class="nav-link-text">Strategy</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link d-flex align-items-center" href="/deeplearning/cnn">
                            <span class="nav-link-text">CNN</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link d-flex align-items-center" href="/deeplearning/rnn">
                            <span class="nav-link-text">RNN</span>
                        </a>
                    </li>
                </ul>
            </div>
        </li>

        <li class="nav-item">
            <a class="nav-link d-flex align-items-center" href="/django">
                <i class="fa fa-lg">dj</i>
                <span class="nav-link-text">Django</span>
            </a>
        </li>

        <li class="nav-item">
            <a class="nav-link d-flex align-items-center" href="/spring">
                <i class="fas fa-leaf fa-lg"></i>
                <span class="nav-link-text">Spring</span>
            </a>
        </li>

    </ul>
</div>


            <!-- Column: Content Wrapper -->
            <div class="col">
                <div id="content" class="w-100">
<div id="post-wrap" class="row d-flex justify-content-center">

    <div class="card col-md-10 col-xs-12 mt-5">

        <div class="card-header">
            <h1 class="post-title">Kubernetes Essentials</h1>
            <h6 class="card-subtitle post-meta"> 
                Thursday, 15 December 2022
                
            </h6>            
        </div>

        <hr class="post-ruler">

        <div class="card-body">
            <nav>
  <h4>Table of Contents</h4>
<ol id="markdown-toc">
  <li>
<a href="#introduction" id="markdown-toc-introduction">Introduction</a>    <ol>
      <li><a href="#what-is-container-orchestration" id="markdown-toc-what-is-container-orchestration">What is Container Orchestration?</a></li>
      <li><a href="#terminologies" id="markdown-toc-terminologies">Terminologies</a></li>
    </ol>
  </li>
  <li>
<a href="#core-components" id="markdown-toc-core-components">Core components</a>    <ol>
      <li><a href="#node" id="markdown-toc-node">Node</a></li>
      <li><a href="#container" id="markdown-toc-container">Container</a></li>
      <li><a href="#pod" id="markdown-toc-pod">Pod</a></li>
      <li><a href="#service" id="markdown-toc-service">Service</a></li>
      <li><a href="#ingress" id="markdown-toc-ingress">Ingress</a></li>
      <li><a href="#configmap" id="markdown-toc-configmap">ConfigMap</a></li>
      <li><a href="#secret" id="markdown-toc-secret">Secret</a></li>
      <li><a href="#volume" id="markdown-toc-volume">Volume</a></li>
      <li><a href="#replicas" id="markdown-toc-replicas">Replicas</a></li>
      <li><a href="#deployment" id="markdown-toc-deployment">Deployment</a></li>
      <li><a href="#statefulset" id="markdown-toc-statefulset">StatefulSet</a></li>
    </ol>
  </li>
  <li>
<a href="#architecture" id="markdown-toc-architecture">Architecture</a>    <ol>
      <li><a href="#worker-nodes" id="markdown-toc-worker-nodes">Worker Nodes</a></li>
      <li><a href="#master-nodes" id="markdown-toc-master-nodes">Master Nodes</a></li>
      <li><a href="#master-vs-worker-nodes" id="markdown-toc-master-vs-worker-nodes">Master Vs worker Nodes</a></li>
    </ol>
  </li>
  <li>
<a href="#single-node-cluster" id="markdown-toc-single-node-cluster">Single node cluster</a>    <ol>
      <li><a href="#minikube" id="markdown-toc-minikube">Minikube</a></li>
      <li><a href="#kubectl" id="markdown-toc-kubectl">Kubectl</a></li>
      <li><a href="#installation" id="markdown-toc-installation">Installation</a></li>
      <li><a href="#verify-installation" id="markdown-toc-verify-installation">Verify Installation</a></li>
      <li>
<a href="#kubectl-core-commands" id="markdown-toc-kubectl-core-commands">Kubectl core commands</a>        <ol>
          <li><a href="#basic-commands" id="markdown-toc-basic-commands">Basic commands</a></li>
          <li><a href="#crud-of-k8s-component" id="markdown-toc-crud-of-k8s-component">CRUD of K8s component</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#basic-deployment-with-service" id="markdown-toc-basic-deployment-with-service">Basic deployment with service</a></li>
  <li><a href="#mongodb--mongoexpress-deployment" id="markdown-toc-mongodb--mongoexpress-deployment">MongoDB &amp; MongoExpress deployment</a></li>
  <li>
<a href="#namespace" id="markdown-toc-namespace">Namespace</a>    <ol>
      <li><a href="#built-in-namespaces" id="markdown-toc-built-in-namespaces">Built-in namespaces</a></li>
      <li><a href="#custom-namespace" id="markdown-toc-custom-namespace">Custom namespace</a></li>
      <li><a href="#use-of-namespace" id="markdown-toc-use-of-namespace">Use of namespace</a></li>
      <li><a href="#sharing-between-namespaces" id="markdown-toc-sharing-between-namespaces">Sharing between namespaces</a></li>
      <li><a href="#global-components" id="markdown-toc-global-components">Global Components</a></li>
      <li><a href="#kubectl-and-namespace" id="markdown-toc-kubectl-and-namespace">Kubectl and namespace</a></li>
    </ol>
  </li>
  <li>
<a href="#ingress-1" id="markdown-toc-ingress-1">Ingress</a>    <ol>
      <li><a href="#ingress-component" id="markdown-toc-ingress-component">Ingress Component</a></li>
      <li><a href="#ingress-controller" id="markdown-toc-ingress-controller">Ingress Controller</a></li>
      <li><a href="#external-cloud-lb-deployment" id="markdown-toc-external-cloud-lb-deployment">External Cloud LB deployment</a></li>
      <li><a href="#external-proxy-server-deployment" id="markdown-toc-external-proxy-server-deployment">External Proxy Server deployment</a></li>
      <li>
<a href="#minikube-deployment" id="markdown-toc-minikube-deployment">MiniKube deployment</a>        <ol>
          <li><a href="#enable-ingress-controller" id="markdown-toc-enable-ingress-controller">Enable Ingress Controller</a></li>
        </ol>
      </li>
      <li>
<a href="#dashboard-for-k8s" id="markdown-toc-dashboard-for-k8s">Dashboard for K8s</a>        <ol>
          <li><a href="#enable-dashboard" id="markdown-toc-enable-dashboard">Enable dashboard</a></li>
          <li><a href="#configure-ingress" id="markdown-toc-configure-ingress">Configure Ingress</a></li>
          <li><a href="#apply-ingress-component" id="markdown-toc-apply-ingress-component">Apply Ingress Component</a></li>
        </ol>
      </li>
      <li><a href="#default-back-end" id="markdown-toc-default-back-end">Default back-end</a></li>
      <li>
<a href="#ingress-routing-use-cases" id="markdown-toc-ingress-routing-use-cases">Ingress routing use-cases</a>        <ol>
          <li><a href="#path-prefix-based-routing" id="markdown-toc-path-prefix-based-routing">Path prefix based routing</a></li>
          <li><a href="#sub-domain-based-routing" id="markdown-toc-sub-domain-based-routing">Sub-domain based routing</a></li>
        </ol>
      </li>
      <li>
<a href="#ingress-tls-certificates" id="markdown-toc-ingress-tls-certificates">Ingress TLS Certificates</a>        <ol>
          <li><a href="#ingress-config" id="markdown-toc-ingress-config">Ingress Config</a></li>
          <li><a href="#tls-certificate-secret-component" id="markdown-toc-tls-certificate-secret-component">TLS Certificate secret component</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
<a href="#helm" id="markdown-toc-helm">Helm</a>    <ol>
      <li>
<a href="#helm-as-package-manager" id="markdown-toc-helm-as-package-manager">Helm as package manager</a>        <ol>
          <li><a href="#helm-charts" id="markdown-toc-helm-charts">Helm Charts</a></li>
        </ol>
      </li>
      <li>
<a href="#helm-as-templating-engine" id="markdown-toc-helm-as-templating-engine">Helm as templating engine</a>        <ol>
          <li><a href="#yaml-template-file" id="markdown-toc-yaml-template-file">YAML template file</a></li>
          <li><a href="#yaml-value-file" id="markdown-toc-yaml-value-file">YAML value file</a></li>
        </ol>
      </li>
      <li><a href="#same-app-deployed-across-different-environment" id="markdown-toc-same-app-deployed-across-different-environment">Same App deployed across different environment</a></li>
      <li><a href="#helm-chart-structure" id="markdown-toc-helm-chart-structure">Helm Chart Structure</a></li>
      <li>
<a href="#install-helm-chart" id="markdown-toc-install-helm-chart">Install helm chart</a>        <ol>
          <li><a href="#install-with-default-values" id="markdown-toc-install-with-default-values">Install with default values</a></li>
          <li><a href="#install-with-custom-values" id="markdown-toc-install-with-custom-values">Install with custom values</a></li>
        </ol>
      </li>
      <li><a href="#tiller" id="markdown-toc-tiller">Tiller</a></li>
    </ol>
  </li>
  <li><a href="#volumes" id="markdown-toc-volumes">Volumes</a></li>
</ol>

</nav>

<h1 id="introduction">Introduction</h1>

<p>Kubernetes is an open source, <strong>container orchestration</strong> tool that operates in a <strong>distributed</strong> environment at <strong>scale</strong>. Kubernetes comes from the Greek word that means <em>“The person who steers the ship”</em>. Hence the logo.</p>

<blockquote>
  <p>K8s is short for Kubernetes</p>
</blockquote>

<h2 id="what-is-container-orchestration">What is Container Orchestration?</h2>

<p>The rise of micro-services required an environment where each service/application could run in its own virtual environment with its bare minimum system libraries – This resulted in container architecture  – Docker being the most popular. A container orchestration framework like K8s provides</p>

<ul>
  <li>High Availability – Zero downtime.</li>
  <li>Scalability – Ability to take more load or less load on need basis.</li>
  <li>Self healing – Ability to recover from failures.</li>
</ul>

<h2 id="terminologies">Terminologies</h2>

<table>
  <thead>
    <tr>
      <th>Term</th>
      <th>Detail</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Node</td>
      <td>A Kubernetes Node is any Linux host \(-\) VM, bare metal or even private/public cloud instance.</td>
    </tr>
    <tr>
      <td>Pod</td>
      <td>Smallest unit of K8s that provides abstraction over container. A pod is for K8s as container is for Docker. K8s is <strong>not</strong> coupled with Docker. <br>K8s provides an abstraction so that user interacts with K8s layer and doesn’t need to directly interact with the container provider. Docker can be replaced with any other container runtime that meets the spec.</td>
    </tr>
    <tr>
      <td>K8s Cluster</td>
      <td>Used interchangeably as just Kubernetes, is made up of master and worker nodes.</td>
    </tr>
    <tr>
      <td>Microservice App</td>
      <td>A microservice app is an application made up several independent parts called <strong>services.</strong>. The services work together to create a meaningful application.</td>
    </tr>
    <tr>
      <td>K8s Master Node</td>
      <td>A collection of services that make up the control panel and are in-charge of the K8s cluster. Master schedules apps, monitors worker nodes, implements changes and responds to events.</td>
    </tr>
    <tr>
      <td>K8s Worker Node</td>
      <td>The app services run on the K8s worker node or just node.</td>
    </tr>
    <tr>
      <td>Deployment</td>
      <td>A YAML manifest file that answers (A) What the app needs? (B) Scale \(-\) How many replica apps?</td>
    </tr>
  </tbody>
</table>

<h1 id="core-components">Core components</h1>

<h2 id="node">Node</h2>

<p>A node is a physical machine or a virtual machine (VM).</p>

<h2 id="container">Container</h2>

<p>A container is like a womb for an application (app). It contains only those system and app libraries that are required to run the app. It provides the app with an environment as if the app is running in its own machine (node).</p>

<h2 id="pod">Pod</h2>

<p>A pod is a K8s component that provides an abstraction layer over the container. The user interacts with the pod and not directly with the container. This way, the container provider can be replaced with any other container provider that follows the spec. Docker is the most popular container provider.</p>

<ul>
  <li>Pod should usually contain one application (app).</li>
  <li>Pod could have other small helper apps that work coherently with each other.</li>
  <li>Pod (not container) gets its own internal IP.</li>
  <li>Pods can communicate with each other using <strong>internal</strong> IP address</li>
  <li>Pods are ephemeral – Pod can die due to node crash, container crash, resource got exhausted resulting in crash or pod  got relocated to another node.</li>
  <li>When a pod dies, it is recreated. Thus recreated pod can reside in any node and it gets another IP.</li>
  <li>Pods <strong>cannot rely on communicating with internal IP</strong> as it can change and is not reliable. This is solved using another K8s component called Service.</li>
</ul>

<h2 id="service">Service</h2>

<p>A service is a K8s component that can be attached to each Pod.</p>

<ul>
  <li>The service provides a permanent IP address.</li>
  <li>Pods communicate with each other via their services.</li>
  <li>The lifecycle of Pod and service are not connected. So, even if the Pod dies, the service will stay.</li>
  <li>An <strong>external service</strong> needs to be created to expose the Pod for web requests.</li>
  <li>An <strong>internal service</strong> is used for inter Pod communication</li>
  <li>An external service URL with look like <code class="language-plaintext highlighter-rouge">http://&lt;node-ip&gt;:&lt;port&gt;</code>. However, we want the URL to look like <code class="language-plaintext highlighter-rouge">http://app-name</code>. This is achieved using a K8s component called <strong>Ingress</strong>.</li>
  <li>External request goes to Ingress which then forwards the request to the corresponding service.</li>
  <li>Internally Pods communicate using the service.</li>
</ul>

<h2 id="ingress">Ingress</h2>

<p>A ingress is the end-point for external browser requests to route traffic into the K8s cluster. Ingress provides a way to access service using the service name like <code class="language-plaintext highlighter-rouge">http://app-name</code></p>

<h2 id="configmap">ConfigMap</h2>

<p>Let’s say we need to change a container configuration (Like Apache log verbosity). One way of achieving this is to modify the container files, push a new version of container (say to docker-hub), ask K8s to upgrade to the new version of the container. This is very tedious for every small config change to be done.</p>

<p>K8s provides a more elegant solution via ConfigMap</p>

<ul>
  <li>ConfigMap contains the configuration of the component</li>
  <li>ConfigMap is attached to the Pod</li>
  <li>The ConfigMap object is updated for any config change to be done.</li>
  <li>Even if the pod crashes, it shall be restarted and will start running with the config as per ConfigMap</li>
</ul>

<blockquote>
  <p>Don’t put credentials in ConfigMap. Use Secret.</p>
</blockquote>

<h2 id="secret">Secret</h2>

<p>A container configuration can also be something like login credentials. Creating a ConfigMap for this case will be insecure as ConfigMap is plain text. This is handled using K8s component <strong>Secret</strong>.</p>

<ul>
  <li>Secret is Base64 encoded.</li>
  <li>Secret is attached to a Pod just like ConfigMap.</li>
  <li>The value in secret can be accessed inside the application as environment variable or properties file.</li>
</ul>

<blockquote>
  <p>Credentials and certificates are stored as Secret</p>
</blockquote>

<h2 id="volume">Volume</h2>

<p>When a pod dies, the data that the pod has generated dies with it. This data could be less significant data like log or a lot more significant data like database entries. In order to persist the data even after pod’s reincarnation we need another K8s component called <strong>Volumes</strong>.</p>

<blockquote>
  <p>A volume abstracts storage that is attached to the pod</p>
</blockquote>

<p>This storage could be on the same Node, a remote storage on some other node, a cloud storage</p>

<blockquote>
  <p><strong>Note:</strong> A storage has be visualised as external to the K8s cluster. K8s does not manage data persistance!</p>
</blockquote>

<p>This means a user and/or administrator is responsible for the following storage management</p>

<ul>
  <li>Data distribution – Spread chunks of data across physical nodes</li>
  <li>Data redundancy – Maintain multiple copies of data</li>
  <li>Ensure data is kept on reliable hardware (with parity check) from which it can be restored.</li>
</ul>

<h2 id="replicas">Replicas</h2>

<p>With the setup the service is accessible via a external browser. If a pod dies, it gets recreated. However, there is a window of time between crash and recreation where the service is unavailable. In order to provide high availability, that is zero down time of a service, we need multiple replicas of the pod running (preferably distributed on different nodes).</p>

<ul>
  <li>Multiple replicas of the pod shall be connected to the <strong>same</strong> service object.</li>
  <li>The service provides a persistent static IP address with DNS name, that remains even if pod dies and gets recreated.</li>
  <li>The service also provides a built-in load balancer that distributes load among pods.</li>
</ul>

<blockquote>
  <p>A service provides persistent static IP as well as built-in load balancing.</p>
</blockquote>

<p>Replicas are not manually created by creating multiple pods. Instead we configure our requirements in a YAML file (desired state) and create a K8s component called <strong>Deployment</strong>.</p>

<h2 id="deployment">Deployment</h2>

<p>A deployment is a K8s component that provides another layer of abstraction on top of pods – Pods are an abstraction over containers. Deployment provide an easy way to configure, create, replicate, scale-up and scale-down pods. In practice, we mostly work with deployments and not directly with pods.</p>

<blockquote>
  <p>Do not use Deployment to create database pods or any pod that has to maintain state. Use StatefulSet.</p>
</blockquote>

<h2 id="statefulset">StatefulSet</h2>

<p>A deployment cannot be used in case of stateful applications such as database.</p>

<p>A stateful application has the following complications in case of multiple pods (say database pods)</p>

<ul>
  <li>To maintain consistency they could be accessing the same database storage. In this case multiple pods will try read and write that needs be syncronized.</li>
  <li>If we have a database storage per pod, then these storages must be in sync.</li>
</ul>

<p>A mechanism that governs which pod shall write to the storage, which shall read is required in addition to replicating feature. This is offered by K8s component called <strong>StatefulSet</strong>. As the name indicates a StatefulSet is meant specifically for applications like databases (like MySQL, MongoDB, ElasticSearch).</p>

<blockquote>
  <p>Pods that need to maintain state should be created using <strong>StatefulSet</strong>.</p>
</blockquote>

<p>Like Deployment, StatefulSet also takes care of configuration, replication, scale-up and scale-down (while avoiding database inconsistencies). Deploying database apps using StatefulSet in K8s cluster is much more tedious than deployment. So, it is common practice to <strong>host database outside K8s cluster</strong>.</p>

<h1 id="architecture">Architecture</h1>

<h2 id="worker-nodes">Worker Nodes</h2>

<p>Each K8s worker node will have multiple pods running on it. The worker nodes do most of the work and hence the name.</p>

<p>Every worker nodes must have the following <strong>three</strong> processes running</p>

<ul>
  <li>Container runtime – The most popular container runtime is Docker.</li>
  <li>Kubelet – A K8s process that schedules the pods in the nodes. Kubelet is responsible for running the pod inside the node and assigning resources from the node to the pod. So Kubelet manages the node and the container runtime.</li>
  <li>Kube Proxy – We said a K8s service, with a static IP shall load-balance among pod distributed in multiple nodes. The service actually goes via the kube-proxy. If a source pod is making a request to access another target pod via service. The service prioritises a target  pod running on the same node thus reducing network overhead.</li>
</ul>

<h2 id="master-nodes">Master Nodes</h2>

<p>Master Nodes take care of the following</p>

<ul>
  <li>Interacting with the worker nodes</li>
  <li>Adding and removing nodes from the K8s cluster</li>
  <li>Monitor the pods</li>
  <li>Re-order or recreate pods across nodes</li>
</ul>

<p>Every master node has the following <strong>four</strong> process running</p>

<ul>
  <li>API Server
    <ul>
      <li>A user interacts with the API server using some client – The client could be K8s UI dashboard, kubelet CLI or K8s APIs</li>
      <li>API server acts as <strong>cluster gateway</strong> – Gets initial request of any updates or query from the client.</li>
      <li>API server acts as <strong>gatekeeper</strong> – Ensure Authenticated requests get through to the cluster.</li>
      <li>Any request first reaches API Server, gets validated and is then forwarded to other process on the master nodes.</li>
      <li>Any monitoring request/query regarding <strong>status or health of the deployment</strong> happens via API Server</li>
      <li>This is good for security as there is only <strong>one entry point</strong> into the cluster.</li>
    </ul>
  </li>
  <li>Scheduler
    <ul>
      <li>Say, we want to start a new pod. The request goes to API Server which then forwards the request to Scheduler</li>
      <li>The Scheduler shall start the pod on the worker node.</li>
      <li>The Scheduler has the <strong>intelligence</strong> to pick the worker node for a given pod and does not just do it randomly. For example, the scheduler looks at the resources required by the pod, the available resources on each worker node, the type of pods already running on each worker node etc to pick the target worker node.</li>
      <li>The Scheduler only picks the target node. The process that actually starts the pod is the Kubelet running on that worker node.</li>
    </ul>
  </li>
  <li>Controller Manager
    <ul>
      <li>
<strong>Detect state changes</strong>  – For example, pods die on any node</li>
      <li>After detection, the control manager shall contact the scheduler to schedule the pod creation.</li>
      <li>The control manager thus detects state changes and ensures state is maintained.</li>
    </ul>
  </li>
  <li>etcd
    <ul>
      <li>A key-value store of the K8s cluster state – It can be considered as the <strong>cluster brain</strong>.</li>
      <li>All changes of pod’s death, recreation etc are all stored in etcd.</li>
      <li>All this mechanism of scheduler, controller manager <strong>works based on the data</strong> stored in etcd.
        <ul>
          <li>How does Scheduler know what resources are available on which worker node?</li>
          <li>How Controller Manager know that the cluster state changed – pod died or Kubelet restarted a pod etc?</li>
          <li>How does API Server know about the health/status of a deployment?</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>A K8s cluster is typically made up of multiple master nodes each running all these processes.</p>

<ul>
  <li>The API server is load balanced across master nodes</li>
  <li>etcd forms a distributed storage across all the master nodes</li>
</ul>

<h2 id="master-vs-worker-nodes">Master Vs worker Nodes</h2>

<p>Master nodes require less resources. Worker nodes do the actual work and may need more resources and more instances. A small cluster deployment may have two master and three worker nodes.</p>

<p>A master/worker node is added as follows</p>

<ul>
  <li>Get a bare metal server</li>
  <li>Install corresponding master/worker processes</li>
  <li>Add the node to the K9s cluster</li>
</ul>

<h1 id="single-node-cluster">Single node cluster</h1>

<h2 id="minikube">Minikube</h2>

<p>A production cluster have multiple (at-least 2) master nodes and several worker nodes (at-least 3). However to setup a cluster on a local machine (laptop) we can use an open source tool called minikube.</p>

<p>Minikube creates a single node K8s cluster with master and worker processes for testing purposes.</p>

<h2 id="kubectl">Kubectl</h2>

<p>We have seen that <strong>API Server</strong> component of of K8s Master is the entry point for interacting with K8s to perform any operation. We can interact with the API Server using</p>

<ul>
  <li>Kubernetes UI dashboard</li>
  <li>Kubernetes API</li>
  <li>Kubectl CLI</li>
</ul>

<p>The Kubectl CLI is the most popular and powerful way of interaction with K8s cluster be it Minikube, production cluster, AWS, google cloud or even hybrid cluster.</p>

<h2 id="installation">Installation</h2>

<p><a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker on Ubuntu</a></p>

<p><a href="https://minikube.sigs.k8s.io/docs/start/">Install Minikube</a></p>

<h2 id="verify-installation">Verify Installation</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> docker <span class="nt">--version</span>
Docker version 20.10.21, build baeda1f

<span class="o">&gt;</span> minikube version
minikube version: v1.28.0
commit: 986b1ebd987211ed16f8cc10aed7d2c42fc8392f

<span class="o">&gt;</span> kubectl version <span class="nt">--output</span><span class="o">=</span>yaml
clientVersion:
  buildDate: <span class="s2">"2022-10-12T10:57:26Z"</span>
  compiler: gc
  gitCommit: 434bfd82814af038ad94d62ebe59b133fcb50506
  gitTreeState: clean
  gitVersion: v1.25.3
  goVersion: go1.19.2
  major: <span class="s2">"1"</span>
  minor: <span class="s2">"25"</span>
  platform: linux/amd64
kustomizeVersion: v4.5.7
serverVersion:
  buildDate: <span class="s2">"2022-10-12T10:49:09Z"</span>
  compiler: gc
  gitCommit: 434bfd82814af038ad94d62ebe59b133fcb50506
  gitTreeState: clean
  gitVersion: v1.25.3
  goVersion: go1.19.2
  major: <span class="s2">"1"</span>
  minor: <span class="s2">"25"</span>
  platform: linux/amd64

<span class="o">&gt;</span> minikube start
minikube v1.28.0 on Ubuntu 22.04
...
...
Done! kubectl is now configured to use <span class="s2">"minikube"</span> cluster and <span class="s2">"default"</span> namespace by default

<span class="o">&gt;</span> kubectl get nodes
NAME       STATUS   ROLES           AGE   VERSION
minikube   Ready    control-plane   10h   v1.25.3

<span class="o">&gt;</span> minikube status
minikube
<span class="nb">type</span>: Control Plane
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

</code></pre></div></div>

<h2 id="kubectl-core-commands">Kubectl core commands</h2>

<h3 id="basic-commands">Basic commands</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># First off, start the K8s cluster</span>
<span class="o">&gt;</span> minikube start

<span class="c"># A set of master nodes is called a control-pane</span>
<span class="o">&gt;</span> kubectl get nodes
NAME       STATUS   ROLES           AGE   VERSION
minikube   Ready    control-plane   10h   v1.25.3

<span class="c"># Note there are no pods</span>
<span class="o">&gt;</span> kubectl get pods
No resources found <span class="k">in </span>default namespace.

<span class="o">&gt;</span> kubectl get services
NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>   AGE
kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   10h

</code></pre></div></div>

<h3 id="crud-of-k8s-component">CRUD of K8s component</h3>

<p>In this case we are looking at the CRUD operations on the Deployment K8s component. The same applies to other K8s components as well.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Usage</span>
kubectl create deployment NAME <span class="nt">--image</span><span class="o">=</span>image <span class="nt">--</span> <span class="o">[</span>COMMAND] <span class="o">[</span>args...] <span class="o">[</span>options]
kubectl <span class="o">(</span>edit|delete<span class="o">)</span> deployment NAME

<span class="c"># Create deployment</span>
<span class="c"># -----------------</span>
<span class="o">&gt;</span> kubectl create deployment httpd <span class="nt">--image</span><span class="o">=</span>httpd
deployment.apps/httpd created

<span class="c"># Status: Deployment not yet ready</span>
<span class="o">&gt;</span> kubectl get deployments
NAME        READY   UP-TO-DATE   AVAILABLE   AGE
httpd   0/1     1            0           12s

<span class="c"># Status: Deployment now ready</span>
<span class="o">&gt;</span> kubectl get deployments
NAME        READY   UP-TO-DATE   AVAILABLE   AGE
httpd   1/1     1            1           42s

<span class="c"># Status: Get replica sets of the deployment</span>
<span class="o">&gt;</span> kubectl get replicasets
NAME                   DESIRED   CURRENT   READY   AGE
httpd-574c8fb7c5   1         1         1       115s

<span class="c"># Status: Get pods -- Note that the replicaset name is prefixed to the pod's name</span>
<span class="o">&gt;</span> kubectl get pods
NAME                         READY   STATUS    RESTARTS   AGE
httpd-574c8fb7c5-k9nh6   1/1     Running   0          90s

<span class="c"># Debug: Log of pods</span>
<span class="c"># ------------------</span>
<span class="o">&gt;</span> kubectl logs httpd-574c8fb7c5-k9nh6
AH00558: httpd: Could not reliably determine the server<span class="s1">'s fully qualified domain name, using 172.17.0.5. Set the '</span>ServerName<span class="s1">' directive globally to suppress this message
[Wed Dec 07 04:34:40.810356 2022] [mpm_event:notice] [pid 1:tid 140054806654272] AH00489: Apache/2.4.54 (Unix) configured -- resuming normal operations

# Debug: Get interactive terminal
# -------------------------------
&gt; kubectl exec -it httpd-574c8fb7c5-k9nh6 -- bash

# Edit deployment
# -----------
&gt; kubectl edit httpd

# Delete deployment
# -----------------
&gt; kubectl delete httpd
deployment.apps "httpd" deleted
</span></code></pre></div></div>

<h1 id="basic-deployment-with-service">Basic deployment with service</h1>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiZmxvd2NoYXJ0IFRCXG5hMVtodHRwZF0tLS1hMihTZXJ2aWNlKTo6OnNlcnZpY2VcbmExKGh0dHBkKS0tLWEzKENvbmZpZ01hcCk6Ojpjb25maWdcbiUlLVxuY2xhc3NEZWYgbm9kZSAgICBmaWxsOiNiNGRjZmYsY29sb3I6YmxhY2ssc3Ryb2tlOiMyODY0ZGM7XG5jbGFzc0RlZiBzZXJ2aWNlIGZpbGw6IzI4NjRkYyxjb2xvcjp3aGl0ZSxzdHJva2U6IzY0YTBmZjtcbmNsYXNzRGVmIGNvbmZpZyAgZmlsbDojMDBhMDc4LGNvbG9yOndoaXRlLHN0cm9rZTojMDBjOGEwOyIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0In19"></p>

<p>The <a href="K8s/01-basic">K8s/01-basic</a> project details the following concepts</p>

<ul>
  <li>Deployment, replicas, pods and service</li>
  <li>Accessing via Node IP, internal Service IP and Pod IP</li>
  <li>Assert service load balancing, self healing of pods, scaling of pods</li>
  <li>Assert Service IP and ConfigMap persistance</li>
  <li>Test out-of-box Zero downtime when pod is deleted during load</li>
</ul>

<h1 id="mongodb--mongoexpress-deployment">MongoDB &amp; MongoExpress deployment</h1>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiZmxvd2NoYXJ0IFRCXG4lJS1cbmQxKE1vbmdvREIpOjo6bm9kZS0tLWcxKFNlcnZpY2UpOjo6c2VydmljZVxuZDEtLS1nMihEQiBTZWNyZXQpOjo6c2VjcmV0XG4lJS1cbmQyKE1vbmdvRXhwcmVzcyk6Ojpub2RlLS0tZzJcbmQyLS0tZzMoTEIgU2VydmljZSk6OjpzZXJ2aWNlXG5kMi0tLWc0KERCIENvbmZpZyBNYXApOjo6Y29uZmlnXG4lJS1cbmNsYXNzRGVmIG5vZGUgICAgZmlsbDojYjRkY2ZmLGNvbG9yOmJsYWNrLHN0cm9rZTojMjg2NGRjO1xuY2xhc3NEZWYgc2VydmljZSBmaWxsOiMyODY0ZGMsY29sb3I6d2hpdGUsc3Ryb2tlOiM2NGEwZmY7XG5jbGFzc0RlZiBjb25maWcgIGZpbGw6IzAwYTA3OCxjb2xvcjp3aGl0ZSxzdHJva2U6IzAwYzhhMDtcbmNsYXNzRGVmIHNlY3JldCAgZmlsbDojYjQ3ODAwLGNvbG9yOndoaXRlLHN0cm9rZTojYzg4YzAwO1xuJSUtIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifX0"></p>

<p>The <a href="https://github.com/cafeduke/learn/tree/master/K8s/02-mongo">K8s/02-mongo</a> project details the following concepts</p>

<ul>
  <li>Secret and ConfigMap</li>
  <li>Deployments sharing Secret component</li>
  <li>Request flow through pods and services when user accesses MongoExpress UI</li>
</ul>

<h1 id="namespace">Namespace</h1>

<p>Namespaces are used to group resources inside a K8s cluster. Like any namespace it avoids name conflict.</p>

<h2 id="built-in-namespaces">Built-in namespaces</h2>

<p>By default K8s provides the following namespaces</p>

<table>
  <thead>
    <tr>
      <th>Namespace</th>
      <th>Comment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>kubernetes-dashboard</td>
      <td>Specific to minikube. Not present in standard cluster</td>
    </tr>
    <tr>
      <td>kube-system</td>
      <td>Do <strong>not</strong> use or modify this. This is not meant for user. <br>The components deployed are system processes.</td>
    </tr>
    <tr>
      <td>kube-public</td>
      <td>Data accessible by public. <br>It has <code class="language-plaintext highlighter-rouge">ConfigMap</code> with cluster information that can be accessed without authentication. <br>Execute <code class="language-plaintext highlighter-rouge">kubectl clusterinfo</code> to see details.</td>
    </tr>
    <tr>
      <td>kube-node-lease</td>
      <td>A recent addition. Holds information about heartbeat of nodes indicating availability.</td>
    </tr>
    <tr>
      <td>default</td>
      <td>This is the namespace used when none is specified.</td>
    </tr>
  </tbody>
</table>

<h2 id="custom-namespace">Custom namespace</h2>

<p>Various K8s components (Deployments, ConfigMap, Secret) can be grouped under a custom namespace by specifying the name of the namespace in <code class="language-plaintext highlighter-rouge">metadata.namespace</code></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-configmap</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">my-namespace</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="s">...</span>
</code></pre></div></div>

<h2 id="use-of-namespace">Use of namespace</h2>

<ul>
  <li>
<strong>Avoid Cluttering:</strong> Group components into namespaces based on functionality. Eg: Database, Monitoring, LB, Logging</li>
  <li>
<strong>Multiple teams using same cluster:</strong> Avoid accidental overwriting of components having same name.</li>
  <li>
<strong>Resources sharing in same cluster:</strong> We can have staging and development environments share namespaces like Logging (ElasticStack) and LB(Nginx-Ingress Controller). This avoids creating redundant components for staging and development separately.</li>
  <li>
<strong>Blue-Green Deployment:</strong> Similar to staging and development. Blue is environment under development and green is the current environment.</li>
  <li>
<strong>Limit access and resources via namespace</strong>: Configure access such that, members of projectA-namespace, for example, cannot access components in projectB-namespace.  Provide resource quota (CPU, RAM, Storage) per namespace. This way one team will not hog most resources of the K8s cluster.</li>
</ul>

<h2 id="sharing-between-namespaces">Sharing between namespaces</h2>

<p>One namespace cannot refer to most components (ConfigMap, Secret) in another namespace</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiZmxvd2NoYXJ0IFRCXG4lJS1cbnN1YmdyYXBoIGRiLW5hbWVzcGFjZVxuZGlyZWN0aW9uIFRCXG5kYjEobXlzcWwpXG5kYjIobXlzcWwtc2VydmljZSk6OjpzZXJ2aWNlXG5lbmRcbiUlLVxuc3ViZ3JhcGggYTItbmFtZXNwYWNlXG5kaXJlY3Rpb24gVEJcbmEyYzEoQTIpXG5hMmMyKG15LWNvbmZpZ21hcCk6Ojpjb25maWdcbmEyYzMobXktc2VjcmV0KTo6OnNlY3JldFxuZW5kXG4lJS1cbnN1YmdyYXBoIGExLW5hbWVzcGFjZVxuZGlyZWN0aW9uIFRCXG5hMWMxKEExKVxuYTFjMihteS1jb25maWdtYXApOjo6Y29uZmlnXG5hMWMzKG15LXNlY3JldCk6OjpzZWNyZXRcbmVuZFxuJSUtXG5hMWMyLS0tZGIyXG5hMmMyLS0tZGIyXG4lJS1cbmNsYXNzRGVmIG5vZGUgICAgZmlsbDojYjRkY2ZmLGNvbG9yOmJsYWNrLHN0cm9rZTojMjg2NGRjO1xuY2xhc3NEZWYgc2VydmljZSBmaWxsOiMyODY0ZGMsY29sb3I6d2hpdGUsc3Ryb2tlOiM2NGEwZmY7XG5jbGFzc0RlZiBjb25maWcgIGZpbGw6IzAwYTA3OCxjb2xvcjp3aGl0ZSxzdHJva2U6IzAwYzhhMDtcbmNsYXNzRGVmIHNlY3JldCAgZmlsbDojYTA3ODAwLGNvbG9yOndoaXRlLHN0cm9rZTojYTBjODAwO1xuJSUtIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifX0"></p>

<ul>
  <li>We have a <code class="language-plaintext highlighter-rouge">my-configmap</code> that references the DB service in <code class="language-plaintext highlighter-rouge">mysql-service</code> in <code class="language-plaintext highlighter-rouge">a1-namespace</code>. This <code class="language-plaintext highlighter-rouge">ConfigMap</code> cannot be used by <code class="language-plaintext highlighter-rouge">a2-namespace</code>. It will have to create another copy of <code class="language-plaintext highlighter-rouge">ConfigMap</code> component even though the contents are same.</li>
  <li>Similarly, secrets cannot be shared between namespaces even though the contents are same.</li>
  <li>However, <code class="language-plaintext highlighter-rouge">my-configmap</code> in both namespaces refer the same DB service <code class="language-plaintext highlighter-rouge">mysql-service</code> which is in <code class="language-plaintext highlighter-rouge">db-namespace</code>
</li>
</ul>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##</span>
<span class="c1"># my-configmap</span>
<span class="c1"># ------------</span>
<span class="c1"># data.db_url</span>
<span class="c1">#   - Note that fully qualified name is used to reference the service</span>
<span class="c1">#   - The fully qualified service name is of the format &lt;service-name&gt;.&lt;namespace&gt;</span>
<span class="c1">##</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ConfigMap</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-configmap</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="na">db_url</span><span class="pi">:</span> <span class="s">mysql-service.db-namespace</span>
</code></pre></div></div>

<h2 id="global-components">Global Components</h2>

<p>Global components cannot be confined to a namespace. Example of such components are as follows</p>

<ul>
  <li>Volumes</li>
  <li>Node</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># List all global components</span>
<span class="o">&gt;</span> kubectl api-resources <span class="nt">--namespaced</span><span class="o">=</span><span class="nb">false</span>

<span class="c"># List all components that can be namespaced</span>
<span class="o">&gt;</span> kubectl api-resources <span class="nt">--namespaced</span><span class="o">=</span><span class="nb">true</span>
</code></pre></div></div>

<h2 id="kubectl-and-namespace">Kubectl and namespace</h2>

<p>By default, <code class="language-plaintext highlighter-rouge">kubectl</code>  will list components in the <code class="language-plaintext highlighter-rouge">default</code> namespace. For <code class="language-plaintext highlighter-rouge">kubectl</code> to work with custom namespace use the <code class="language-plaintext highlighter-rouge">-n</code> option of <code class="language-plaintext highlighter-rouge">kubectl</code>  as shown below.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> kubectl get pods <span class="nt">-n</span> my-namespace
</code></pre></div></div>

<blockquote>
  <p>The default behaviour can be changed using a third party tool called <strong>kubens</strong></p>
</blockquote>

<h1 id="ingress-1">Ingress</h1>

<p>Consider a simple K8s cluster with a deployment and service (See  <a href="K8s/01-basic">K8s/01-basic</a> project for example). Here, the service is exposed to external request by configuring the <code class="language-plaintext highlighter-rouge">type: LoadBalancer</code> and exposing <code class="language-plaintext highlighter-rouge">nodePort: 30000</code>. The service was accessed using the NodeIP (minikube ip)</p>

<p>Ideally a K8s cluster must be as follows</p>

<ul>
  <li>The service should <strong>not</strong> expose external port (via LB external service)</li>
  <li>The service should be accessible via a domain name</li>
  <li>The service should be accessible via HTTPS protocol</li>
</ul>

<h2 id="ingress-component">Ingress Component</h2>

<p>Ingress provides routing rules and is the entry point into the K8s cluster.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##</span>
<span class="c1"># spec.rules</span>
<span class="c1">#   - When request comes to host route the request to "backend" service</span>
<span class="c1">#   - In this case the backend service is myapp-internal-service</span>
<span class="c1">#   - Since it's internal service we use internal service port</span>
<span class="c1">#   - The service is of defualt type (ClusterIP) and the nodePort config is removed</span>
<span class="c1">##</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myapp-ingress</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">rules</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">myapp.com</span>
      <span class="na">http</span><span class="pi">:</span>
        <span class="na">paths</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">backend</span><span class="pi">:</span>
              <span class="na">serviceName</span><span class="pi">:</span> <span class="s">myapp-internal-service</span>
              <span class="na">servicePort</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre></div></div>

<h2 id="ingress-controller">Ingress Controller</h2>

<p>An Ingress Component is not enough for the Ingress routing rules to work. We also need an <strong>Ingress Controller</strong>.</p>

<ul>
  <li>An Ingress Controller is the actual implementation of Ingress.</li>
  <li>An Ingress Controller is a pod (or set of pods) within K8s cluster that evaluate and process routing rules</li>
  <li>An Ingress Controller manages all traffic, <strong>redirects requests</strong> to corresponding service.</li>
  <li>An Ingress Controller is the single <strong>entry point</strong> into the cluster.</li>
  <li>There are many third party implementations of Ingress Controller. The K8s implementation is <code class="language-plaintext highlighter-rouge">K8s Nginx Ingress Controller</code>
</li>
</ul>

<h2 id="external-cloud-lb-deployment">External Cloud LB deployment</h2>

<p>This is the typical deployment of a K8s cluster.</p>

<ul>
  <li>An external cloud loadbalancer (LB) shall front-end all customer requests and shall forward the request to <code class="language-plaintext highlighter-rouge">IngressController</code>
</li>
  <li>The LB shall have a public IP registered with domain <code class="language-plaintext highlighter-rouge">my-app.com</code>
</li>
</ul>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiZmxvd2NoYXJ0IFJMXG4lJS1cbnN1YmdyYXBoIENsb3VkTEJcbmRpcmVjdGlvbiBMUlxubGIxKE4xKVxubGIyKE4yKVxubGIzKE4zKVxuJSUtXG5sYjEtLS1sYjItLS1sYjNcbmVuZFxuJSUtXG5zdWJncmFwaCBNeUs4c0NsdXN0ZXJcbmRpcmVjdGlvbiBUQlxuYzEoTXlBcHApOjo6bm9kZVxuYzIobXktc2VydmljZSk6OjpzZXJ2aWNlXG5jMyhteS1pbmdyZXNzKTo6OmluZ3Jlc3NcbmM0KEluZ3Jlc3NDb250cm9sbGVyKTo6OmN0bFxuJSUtXG5jNC0tPmMzLS0-YzItLT5jMVxuZW5kXG4lJS1cbkNsb3VkTEItLT5jNFxuJSUtXG5jbGFzc0RlZiBub2RlICAgIGZpbGw6I2I0ZGNmZixjb2xvcjpibGFjayxzdHJva2U6IzI4NjRkYztcbmNsYXNzRGVmIHNlcnZpY2UgZmlsbDojMjg2NGRjLGNvbG9yOndoaXRlLHN0cm9rZTojNjRhMGZmO1xuY2xhc3NEZWYgaW5ncmVzcyBmaWxsOiNiNDc4MDAsY29sb3I6d2hpdGUsc3Ryb2tlOiNjODhjMDA7XG5jbGFzc0RlZiBjdGwgICAgIGZpbGw6IzhjNjQwMCxjb2xvcjp3aGl0ZSxzdHJva2U6I2I0NzgwMDsiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9fQ"></p>

<h2 id="external-proxy-server-deployment">External Proxy Server deployment</h2>

<p>The deployment uses an external proxy server</p>

<ul>
  <li>An external proxy server could be a hardware or software solution.</li>
  <li>The proxy shall be the only entry point to customer requests and shall forward the request to <code class="language-plaintext highlighter-rouge">IngressController</code>
</li>
  <li>The proxy shall have a public IP registered with domain <code class="language-plaintext highlighter-rouge">my-app.com</code>
</li>
</ul>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiZmxvd2NoYXJ0IFJMXG4lJS1cbnN1YmdyYXBoIFByb3h5U2VydmVyXG5kaXJlY3Rpb24gTFJcbnAxKFByb3h5IFNlcnZlcilcbmVuZFxuJSUtXG5zdWJncmFwaCBNeUs4c0NsdXN0ZXJcbmRpcmVjdGlvbiBUQlxuYzEoTXlBcHApOjo6bm9kZVxuYzIobXktc2VydmljZSk6OjpzZXJ2aWNlXG5jMyhteS1pbmdyZXNzKTo6OmluZ3Jlc3NcbmM0KEluZ3Jlc3NDb250cm9sbGVyKTo6OmN0bFxuJSUtXG5jNC0tPmMzLS0-YzItLT5jMVxuZW5kXG4lJS1cblByb3h5U2VydmVyLS0-YzRcbiUlLVxuY2xhc3NEZWYgbm9kZSAgICBmaWxsOiNiNGRjZmYsY29sb3I6YmxhY2ssc3Ryb2tlOiMyODY0ZGM7XG5jbGFzc0RlZiBzZXJ2aWNlIGZpbGw6IzI4NjRkYyxjb2xvcjp3aGl0ZSxzdHJva2U6IzY0YTBmZjtcbmNsYXNzRGVmIGluZ3Jlc3MgZmlsbDojYjQ3ODAwLGNvbG9yOndoaXRlLHN0cm9rZTojYzg4YzAwO1xuY2xhc3NEZWYgY3RsICAgICBmaWxsOiM4YzY0MDAsY29sb3I6d2hpdGUsc3Ryb2tlOiNiNDc4MDA7IiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifX0"></p>

<h2 id="minikube-deployment">MiniKube deployment</h2>

<h3 id="enable-ingress-controller">Enable Ingress Controller</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Automatically starts the K8s-Nginx implementation of Ingress Controller</span>
<span class="o">&gt;</span> minikube addons <span class="nb">enable </span>ingress

<span class="c"># List namespaces</span>
<span class="o">&gt;</span> kubectl get namespaces
NAME              STATUS   AGE
default           Active   6d20h
ingress-nginx     Active   4m11s
kube-node-lease   Active   6d20h
kube-public       Active   6d20h
kube-system       Active   6d20h

<span class="c"># K8s IngressController runs in ingress-nginx namespace</span>
<span class="c"># Note: ingress-nginx-controller-5959f988fd-76rbx</span>
<span class="o">&gt;</span> kubectl get pods <span class="nt">-n</span> ingress-nginx
NAME                                        READY   STATUS      RESTARTS   AGE
ingress-nginx-admission-create-ml8t8        0/1     Completed   0          4m3s
ingress-nginx-admission-patch-7vjd6         0/1     Completed   0          4m3s
ingress-nginx-controller-5959f988fd-76rbx   1/1     Running     0          4m3s

</code></pre></div></div>

<h2 id="dashboard-for-k8s">Dashboard for K8s</h2>

<h3 id="enable-dashboard">Enable dashboard</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> minikube dashboard

<span class="o">&gt;</span> kubectl get ns
NAME                   STATUS   AGE
default                Active   6d20h
ingress-nginx          Active   9m22s
kube-node-lease        Active   6d20h
kube-public            Active   6d20h
kube-system            Active   6d20h
kubernetes-dashboard   Active   2m17s

<span class="o">&gt;</span> kubectl get services <span class="nt">-n</span> kubernetes-dashboard
NAME                        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>    AGE
dashboard-metrics-scraper   ClusterIP   10.100.197.148   &lt;none&gt;        8000/TCP   3m41s
kubernetes-dashboard        ClusterIP   10.109.91.91     &lt;none&gt;        80/TCP     3m41s

</code></pre></div></div>

<h3 id="configure-ingress">Configure Ingress</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##</span>
<span class="c1"># Ingress</span>
<span class="c1"># -------</span>
<span class="c1"># metadata.namespace</span>
<span class="c1">#   - We need to use this to specify that we are using 'kubernetes-dashboard' namespace and NOT default.</span>
<span class="c1">#</span>
<span class="c1"># spec.rules[0].host</span>
<span class="c1">#   - Need to add the host to /etc/hosts</span>
<span class="c1">#</span>
<span class="c1"># spec.rules[0].http.paths[0].backend.serviceName</span>
<span class="c1">#   - The serviceName must match the actual service running in the cluster</span>
<span class="c1">#   - In this case, in the kubernetes-dashboard namespace, kubernetes-dashboard service is runnning</span>
<span class="c1">#</span>
<span class="c1">##</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-dashboard-ingress</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">kubernetes-dashboard</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">rules</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">my.k8s.com</span>
      <span class="na">http</span><span class="pi">:</span>
        <span class="na">paths</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">backend</span><span class="pi">:</span>
              <span class="na">serviceName</span><span class="pi">:</span> <span class="s">kubernetes-dashboard</span>
              <span class="na">servicePort</span><span class="pi">:</span> <span class="m">80</span>
</code></pre></div></div>

<h3 id="apply-ingress-component">Apply Ingress Component</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> kubectl apply <span class="nt">-f</span> myapp-ingress.yml

<span class="c"># Wait for kubernetes to assign a Public IP for ingres</span>
<span class="o">&gt;</span> kubectl get ingress <span class="nt">-n</span> kubernetes-dashboard <span class="nt">--watch</span>

<span class="c"># Use the PublicIP provided by K8s in /etc/hosts</span>
&lt;ip-provided-by-k8s&gt; my.k8s.com

<span class="c"># Access</span>
http://my.k8s.com
</code></pre></div></div>

<h2 id="default-back-end">Default back-end</h2>

<p>Ingress has an attribute called <code class="language-plaintext highlighter-rouge">Default backend</code> that maps to a service named <code class="language-plaintext highlighter-rouge">default-http-backend:80</code>. Any request that Ingress receives that does not match any routing rule shall be directed here. This can be used to provide a custom error page.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##</span>
<span class="c1">#  metadata.name :</span>
<span class="c1">#    - The name should be 'default-http-backend' as Ingress looks for a servcie by the name</span>
<span class="c1">#    - We need to have pods listening at 8080 that provide custom error page</span>
<span class="c1">##</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">default-http-backend</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">my-error-app</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">80</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre></div></div>

<h2 id="ingress-routing-use-cases">Ingress routing use-cases</h2>

<h3 id="path-prefix-based-routing">Path prefix based routing</h3>

<ul>
  <li>Here <code class="language-plaintext highlighter-rouge">http://myapp.com/prefix1</code> shall route the request to Service <code class="language-plaintext highlighter-rouge">prefix1-service</code>
</li>
  <li>Here <code class="language-plaintext highlighter-rouge">http://myapp.com/prefix2</code> shall route the request to Service <code class="language-plaintext highlighter-rouge">prefix2-service</code>
</li>
</ul>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myapp-ingress</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">rules</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">myapp.com</span>
      <span class="na">http</span><span class="pi">:</span>
        <span class="na">paths</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/prefix1</span>
            <span class="na">backend</span><span class="pi">:</span>
              <span class="na">serviceName</span><span class="pi">:</span> <span class="s">prefix1-service</span>
              <span class="na">servicePort</span><span class="pi">:</span> <span class="m">8080</span>
          <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/prefix2</span>
            <span class="na">backend</span><span class="pi">:</span>
              <span class="na">serviceName</span><span class="pi">:</span> <span class="s">prefix2-service</span>
              <span class="na">servicePort</span><span class="pi">:</span> <span class="m">9090</span>

</code></pre></div></div>

<h3 id="sub-domain-based-routing">Sub-domain based routing</h3>

<p>Here the prefix is part of the domain.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myapp-ingress</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">rules</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">prefix1.myapp.com</span>
      <span class="na">http</span><span class="pi">:</span>
        <span class="na">paths</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">backend</span><span class="pi">:</span>
              <span class="na">serviceName</span><span class="pi">:</span> <span class="s">prefix1-service</span>
              <span class="na">servicePort</span><span class="pi">:</span> <span class="m">8080</span>
    <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">prefix2.myapp.com</span>
      <span class="na">http</span><span class="pi">:</span>
        <span class="na">paths</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">backend</span><span class="pi">:</span>
              <span class="na">serviceName</span><span class="pi">:</span> <span class="s">prefix2-service</span>
              <span class="na">servicePort</span><span class="pi">:</span> <span class="m">9090</span>

</code></pre></div></div>

<h2 id="ingress-tls-certificates">Ingress TLS Certificates</h2>

<h3 id="ingress-config">Ingress Config</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##</span>
<span class="c1"># spec.tls.hosts</span>
<span class="c1">#   - The domain hosted by the K8s cluster</span>
<span class="c1">#</span>
<span class="c1">#  spec.tls.secretName</span>
<span class="c1">#    - A reference to the secret component</span>
<span class="c1">##</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myapp-ingress</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">tls</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">hosts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">myapp.com</span>
      <span class="na">secretName</span><span class="pi">:</span> <span class="s">myapp-secret-tls</span>
  <span class="na">rules</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">myapp.com</span>
      <span class="na">http</span><span class="pi">:</span>
        <span class="na">paths</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">backend</span><span class="pi">:</span>
              <span class="na">serviceName</span><span class="pi">:</span> <span class="s">my-service</span>
              <span class="na">servicePort</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre></div></div>

<h3 id="tls-certificate-secret-component">TLS Certificate secret component</h3>

<blockquote>
  <p>The secret has to be created in the same namespace as the Ingress component</p>
</blockquote>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##</span>
<span class="c1"># TLS Certificate secret</span>
<span class="c1"># ----------------------</span>
<span class="c1"># data.tls.crt, data.tls.key</span>
<span class="c1">#   - These are actual certificate contents -- NOT path</span>
<span class="c1">#</span>
<span class="c1"># metadata.namespace</span>
<span class="c1">#   - The ingress myapp-ingress and the secret myapp-cert-secert must be in same namespace</span>
<span class="c1">#   - Components can access Secert/ConfigMap only in the same namespace</span>
<span class="c1">##</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Secret</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myapp-cert-secret</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="na">tls.crt</span><span class="pi">:</span> <span class="s">&lt;base64 encoded cert&gt;</span>
  <span class="na">tls.key</span><span class="pi">:</span> <span class="s">&lt;base64 encoded cert private key&gt;</span>
<span class="na">type</span><span class="pi">:</span> <span class="s">kubernetes.io/tls</span>
</code></pre></div></div>

<h1 id="helm">Helm</h1>

<p>Helm is used in a couple of ways in K8s</p>

<h2 id="helm-as-package-manager">Helm as package manager</h2>

<p>Helm is a package manager for K8s cluster</p>

<ul>
  <li>Just like <code class="language-plaintext highlighter-rouge">apt</code> is package manager in Ubuntu and <code class="language-plaintext highlighter-rouge">yum</code> is package manager in <code class="language-plaintext highlighter-rouge">CentOS</code>
</li>
  <li>Download YAML files from central repository.</li>
  <li>Package, upload and share YAML files for various standard use-cases.</li>
</ul>

<h3 id="helm-charts">Helm Charts</h3>

<ul>
  <li>Lets say, we want to use <code class="language-plaintext highlighter-rouge">ElasticStack</code> for logging. This requires wiring several components such as <code class="language-plaintext highlighter-rouge">Stateful Set</code>, <code class="language-plaintext highlighter-rouge">ConfigMap</code>, <code class="language-plaintext highlighter-rouge">Secert</code>  and <code class="language-plaintext highlighter-rouge">Services</code>. Since <code class="language-plaintext highlighter-rouge">ElasticStack</code> is popular and logging is a frequently required use-case, several people will need the same.</li>
  <li>A reusable bundle of YAML files, shared at a centralised repository, that configures <code class="language-plaintext highlighter-rouge">ElasticStack</code> is useful for many.</li>
  <li>This bundle of YAML files is called <strong>Helm Chart</strong>.</li>
  <li>The repository is called <strong>Helm Repository</strong>.</li>
  <li>Helm charts exists for database Apps like MongoDB, ElasticSearch, MySQL</li>
  <li>Helm charts exists for monitoring Apps like Promotheus</li>
  <li>Look out for helm charts in https://artifacthub.io/</li>
</ul>

<h2 id="helm-as-templating-engine">Helm as templating engine</h2>

<p>Consider a K8s cluster running several microservices.</p>

<ul>
  <li>The YAML config of majority of the services are identical expect for the the values for few parameters like name of the deployment, container name, container image, port numbers etc.</li>
  <li>We could have a <strong>template</strong> YAML file with <strong>placeholders</strong>. The actual YAML can be dynamically generated from a file having values (Data Factory design pattern)</li>
  <li>This is reduce the overhead of user in duplicating YAML files.</li>
</ul>

<h3 id="yaml-template-file">YAML template file</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> 
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> 
    <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> 
    <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span> 
</code></pre></div></div>

<h3 id="yaml-value-file">YAML value file</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">##</span>
<span class="c1"># values.yml</span>
<span class="c1"># ----------</span>
<span class="c1">##</span>
<span class="na">name</span><span class="pi">:</span> <span class="s">my-app</span>
<span class="na">container</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-app-container</span>
  <span class="na">image</span><span class="pi">:</span> <span class="s">my-app-image</span>
  <span class="na">port</span><span class="pi">:</span> <span class="m">9001</span>
</code></pre></div></div>

<blockquote>
  <p>Values is an object created based on the values.yml file.
Template YAML is especially useful in CI-CD where the build pipeline will only have the template file and values can be replaced on the fly.</p>
</blockquote>

<h2 id="same-app-deployed-across-different-environment">Same App deployed across different environment</h2>

<p>Consider a deployment where we have Dev, Stage and Prod K8s clusters using the the same YAML files.</p>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiZmxvd2NoYXJ0IFRCXG4lJS1cbnN1YmdyYXBoIFByb2RDbHVzdGVyXG5kaXJlY3Rpb24gTFJcbmMzZDEoTWljb1NlcnZpY2UtQSlcbmMzZDIoTWljb1NlcnZpY2UtQilcbmMzZDMoTWljb1NlcnZpY2UtQylcbmMzZDQoTWljb1NlcnZpY2UtRClcbmVuZFxuJSUtXG5zdWJncmFwaCBTdGFnZUNsdXN0ZXJcbmRpcmVjdGlvbiBMUlxuYzJkMShNaWNvU2VydmljZS1BKVxuYzJkMihNaWNvU2VydmljZS1CKVxuYzJkMyhNaWNvU2VydmljZS1DKVxuYzJkNChNaWNvU2VydmljZS1EKVxuZW5kXG4lJS1cbnN1YmdyYXBoIERldkNsdXN0ZXJcbmRpcmVjdGlvbiBMUlxuYzFkMShNaWNvU2VydmljZS1BKVxuYzFkMihNaWNvU2VydmljZS1CKVxuYzFkMyhNaWNvU2VydmljZS1DKVxuYzFkNChNaWNvU2VydmljZS1EKVxuZW5kXG4lJS1cbmNsYXNzRGVmIG5vZGUgICAgZmlsbDojYjRkY2ZmLGNvbG9yOmJsYWNrLHN0cm9rZTojMjg2NGRjOyIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0In19"></p>

<p><strong>Issue:</strong> Even if we use templating, we will be generating 3 copies of all YAML files from templates and then deploying a copy per cluster.</p>

<p><strong>Solution:</strong> Generate a custom Helm chart with all YAML files.  Redeploy the same in different clusters.</p>

<h2 id="helm-chart-structure">Helm Chart Structure</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mychart/             <span class="c"># Name of the chart</span>
  Chart.yml        <span class="c"># Meta data about the chart, name version etc</span>
  values.yml     <span class="c"># Default values for place holders</span>
  charts/          <span class="c"># The dependencies for the current chart. May depend on other charts.</span>
  templates/       <span class="c"># Template files</span>
</code></pre></div></div>

<h2 id="install-helm-chart">Install helm chart</h2>

<h3 id="install-with-default-values">Install with default values</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>helm <span class="nb">install</span> &lt;chartname&gt;
</code></pre></div></div>

<p><strong>Working</strong></p>

<ul>
  <li>The template files from <code class="language-plaintext highlighter-rouge">/templates</code> shall be replaced with values in <code class="language-plaintext highlighter-rouge">values.yml</code>
</li>
  <li>This is produce valid K8s YAML ready to be deployed</li>
</ul>

<h3 id="install-with-custom-values">Install with custom values</h3>

<table>
  <thead>
    <tr>
      <th>mychart/values.yml</th>
      <th>my-values.yml</th>
      <th>.Values object</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>imageName: myapp<br>port:8080<br>version: 1.0</td>
      <td>version:2.0</td>
      <td>imageName: myapp<br>port:8080<br>version: 2.0</td>
    </tr>
  </tbody>
</table>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Placeholders in all template files located in mychart/templates/ will be replaced as per .Values object</span>
helm <span class="nb">install</span> <span class="nt">--values</span><span class="o">=</span>my-values.yml mychart
</code></pre></div></div>

<h2 id="tiller">Tiller</h2>

<p>Helm version 3.0 <strong>removes Tiller support</strong> due to security concerns. Tiller was a server that had access to cluster where the YAML versions could be stored and rolledback.</p>

<h1 id="volumes">Volumes</h1>

<todo>
</todo>

        </div>

        <div class="card-footer">
            
        </div>

    </div>

</div>
</div>
                <!-- <div id="footer" class="w-100"><div class="footer">
    <div class="footer-col footer-col-1">
    <ul class="contact-list">
      <li>
        <span class="site-author">
           
             Raghunandan.Seshadri
           
        </span>
      </li>

      
      <li><a href="mailto:raghubs81@gmail.com">raghubs81@gmail.com</a></li>
      

      
      <li>
        <a href="https://github.com/cafeduke"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">cafeduke</span></a>

      </li>
      

    </ul>
    </div>

    <div class="footer-col footer-col-2">
     <ul class="contact-list">
        
           <li>Duke notes. Happy learning!</li>
        
     </ul>
    </div>
</div></div> -->
            </div>
        </div>
    </div>

    <!-- JS -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>

<!-- Popper -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"></script>

<!-- Bootstrap -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>

<!-- Material JavaScript on top of Bootstrap JavaScript -->
<script src="/assets/daemonite-material/js/material.min.js"></script>

<!-- Include and configure MathJax -->
<script type="text/x-mathjax-config">
   MathJax.Hub.Config({
      jax: ["input/AsciiMath", "input/TeX", "input/MathML", "output/HTML-CSS"],
      asciimath2jax: {
         delimiters: [['`','`'], ['$$','$$'], ['$','$']]
      },
      "HTML-CSS": {
         preferredFont:"TeX", availableFonts:["STIX","TeX"]
      }
   });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>

<script src="/assets/js/mermaid.min.js"></script>

<!-- Google analytics -->


<!-- Sidebar -->
<script src="/assets/js/sidebar.js"></script>



   </body>

</html>
